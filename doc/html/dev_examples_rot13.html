

<html>
<head>
<meta http-equiv='content-type' content='text/html; charset=utf-8' />
<link rel='shortcut icon' href='./favicon.ico' />
<title>rot13 - A simple text transform module - SconeServer-0.6.0 manual</title>
<link rel='stylesheet' href='./style/print.css' media='print' type='text/css' />
<link rel='stylesheet' href='./style/main.css' media='screen' type='text/css' />

</head>
<body>
<div class='titlebar'>
<img src='title_sconeserver.jpg' alt='SconeServer'>
</div>
<div id='side'>

<h2>Contents</h2>
<ul>
<li><a href='./index.html'>SconeServer</a></li>
<ul>
<li><a href='./about.html'>About</a></li>
<li><a href='./download.html'>Download</a></li>
<li><a href='./install.html'>Install</a></li>
<li><a href='./config.html'>Configure</a></li>
<li><a href='./modules.html'>Modules</a></li>
<ul>
<li><a href='./mod_sconeserver.html'>sconeserver</a></li>
<li><a href='./mod_router.html'>router</a></li>
<ul>
<li><a href='./mod_router_ip.html'>ip</a></li>
<li><a href='./mod_router_ip6.html'>ip6</a></li>
<li><a href='./mod_router_local.html'>local</a></li>
<li><a href='./mod_router_bluetooth.html'>bluetooth</a></li>
</ul>
<li><a href='./mod_simple.html'>simple</a></li>
<li><a href='./mod_stat.html'>stat</a></li>
<li><a href='./mod_http.html'>http</a></li>
<ul>
<li><a href='./mod_http_getfile.html'>getfile</a></li>
</ul>
<li><a href='./mod_ssl.html'>ssl</a></li>
</ul>
<li><a href='./develop.html'>Development</a></li>
<ul>
<li><a href='./dev_sconed.html'>sconed</a></li>
<li><a href='./dev_libsconex.html'>libsconex</a></li>
<li><a href='./dev_modules.html'>Modules</a></li>
<li><a href='./dev_examples.html'>Examples</a></li>
<ul>
<li><a href='./dev_examples_tuesdayonly.html'>tuesdayonly</a></li>
<li class='index-this'>rot13</li>
</ul>
<li><a href='./dev_build.html'>Build system</a></li>
</ul>
<li><a href='./faq.html'>FAQ</a></li>
</ul>
</ul>


</div>
<h1>rot13 - A simple text transform module</h1>
<div class='box'>
<p>
Here we develop a more complex module, which deploys a stream to perform 
simple transforms on textual data. This could be used as a template for 
modules that provide filtering functionality, such as encryption, compression 
and bandwith limiting.
</p>

<p>
The module is called "rot13" and its purpose is to transform text using the
<a href='http://en.wikipedia.org/wiki/ROT13'>rot13</a> method - commonly used
to obscure the answers to puzzles on internet discussion forums. Both ingoing 
and outgoing channels can be transformed, this is selectable using a pair of 
options passed from the configuration file.
</p>

<p>
This time we split the code into source and header files. As well as a module
class, we also require another class - a stream, which is deployed by the 
module from its connect() method. The stream performs the required transforms 
whenever data is read and written by subsequent streams.
</p>

<p>
First the module class:
</p>

<pre class='file'><div class='head'>--- ../examples/rot13/Rot13Module.h ---</div><div class='body'>/* SconeServer example

Simple rot13 text transform module

Warning: The "encryption" provided by this module should not be considered
secure by any means. Its purpose is to demonstrate the basic principles for
creating modules that modify data streams within the SconeServer framework.

Copyright (c) 2000-2005 Andrew Wedgbury &lt;wedge@sconemad.com&gt; */

#include "sconex/Module.h"

//=============================================================================
// Our module class, which must be derived from scx::Module
class Rot13Module : public scx::Module {

public:

  Rot13Module();
  
  virtual ~Rot13Module();

  virtual std::string info() const;
  
  virtual int init();

  virtual bool connect(
    scx::Descriptor* endpoint,
    scx::ArgList* args
  );

};
</div></pre>
<pre class='file'><div class='head'>--- ../examples/rot13/Rot13Module.cpp ---</div><div class='body'>/* SconeServer example

Simple rot13 text transform module

Copyright (c) 2000-2005 Andrew Wedgbury &lt;wedge@sconemad.com&gt; */

#include "Rot13Module.h"
#include "Rot13Stream.h"

#include "sconex/ModuleInterface.h"

// The following must be present to allow the resulting
// shared object to be used as a SconeServer module.
SCONESERVER_MODULE(Rot13Module);

//=============================================================================
// Constructor
Rot13Module::Rot13Module()
  : scx::Module("rot13", scx::VersionTag(1,0,0))
{
  // Specify module name and version in base constructor
}

//=============================================================================
// Destructor
Rot13Module::~Rot13Module()
{
  // Nothing to do here
}

//=============================================================================
// Return an information string describing this module
std::string Rot13Module::info() const
{
  return "Copyright (c) 2000-2005 Andrew Wedgbury\n"
  "Simple rot13 text transform module\n";
}
  
//=============================================================================
// Initialise the module
int Rot13Module::init()
{
  // Everything is fine so return 0
  return 0;
}

//=============================================================================
// Notification of connection attempt
bool Rot13Module::connect(
  scx::Descriptor* endpoint,
  scx::ArgList* args
)
{
  const scx::ArgInt* a_input =
    dynamic_cast&lt;const scx::ArgInt*&gt;(args-&gt;get(0));
  const scx::ArgInt* a_output =
    dynamic_cast&lt;const scx::ArgInt*&gt;(args-&gt;get(1));

  if (args-&gt;size() != 2 ||
      !a_input ||
      !a_output) {
    log("Invalid options specified");
    return false;
  }
  
  Rot13Stream* s = new Rot13Stream( a_input-&gt;get_int(), a_output-&gt;get_int() );
  s-&gt;add_module_ref(ref());
  
  endpoint-&gt;add_stream(s);
  return true;
}
</div></pre>


<p>
Most of this is similar to the previous example. The only interesting bit is 
the <code>connect()</code> method, where we interpret any arguments that are 
passed from the configuration settings and add a newly constructed Rot13Stream
object to the socket. 
</p>

<p>
Everything else is handled by the Rot13Stream class, which looks like:
</p>

<pre class='file'><div class='head'>--- ../examples/rot13/Rot13Stream.h ---</div><div class='body'>/* SconeServer (http://www.sconemad.com)

Simple Rot13 text transform stream

Copyright (c) 2000-2005 Andrew Wedgbury &lt;wedge@sconemad.com&gt; */

#ifndef rot13Stream_h
#define rot13Stream_h

#include "sconex/Stream.h"

//=========================================================================
class Rot13Stream : public scx::Stream {

public:

  Rot13Stream(
    bool rot_input,
    bool rot_output
  );

  ~Rot13Stream();
  
protected:

  virtual scx::Condition read(void* buffer,int n,int&amp; na);
  virtual scx::Condition write(const void* buffer,int n,int&amp; na);

  char rot13(char c);
  
private:

  bool m_rot_input;
  bool m_rot_output;
  
};

#endif
</div></pre>
<pre class='file'><div class='head'>--- ../examples/rot13/Rot13Stream.cpp ---</div><div class='body'>/* SconeServer (http://www.sconemad.com)

Simple Rot13 text transform stream

Copyright (c) 2000-2005 Andrew Wedgbury &lt;wedge@sconemad.com&gt; */

#include "Rot13Stream.h"

//=========================================================================
Rot13Stream::Rot13Stream(
  bool rot_input,
  bool rot_output
)
  : scx::Stream("rot13"),
    m_rot_input(rot_input),
    m_rot_output(rot_output)
{
}

//=========================================================================
Rot13Stream::~Rot13Stream()
{
}

//=========================================================================
scx::Condition Rot13Stream::read(void* buffer,int n,int&amp; na)
{
  // Skip rot13 operation if not required.
  if (!m_rot_input) {
    return Stream::read(buffer,n,na);
  }

  // Read data into buffer
  scx::Condition c = Stream::read(buffer,n,na);

  // Apply rot13 transform to data in buffer
  char* out_ptr = (char*)buffer;
  for (int i=0; i&lt;na; ++i, ++out_ptr) {
    *out_ptr = rot13(*out_ptr);
  }

  // Return condition from read operation
  return c;
}

//=========================================================================
scx::Condition Rot13Stream::write(const void* buffer,int n,int&amp; na)
{
  // Skip rot13 operation if not required
  if (!m_rot_output) {
    return Stream::write(buffer,n,na);
  }

  // Create a new buffer to hold the transformed data to be written
  char* rot_buffer = new char[n];
  char* out_ptr = rot_buffer;
  char* in_ptr = (char*)buffer;

  // Apply rot13 transform, saving into new buffer
  for (int i=0; i&lt;n; ++i, ++out_ptr, ++in_ptr) {
    *out_ptr = rot13(*in_ptr);
  }

  // Write the new buffer
  scx::Condition c = Stream::write(rot_buffer,n,na);

  // Cleanup buffer
  delete[] rot_buffer;

  // Return condition from write operation
  return c;
}

//=========================================================================
char Rot13Stream::rot13(char c)
{
  const int rot = 13;
  if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
    // Perform transform on lowercase ASCII text
    c = 'a' + ((c - 'a' + rot) % 26);
  } else if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
    // Perform transform on uppercase ASCII text
    c = 'A' + ((c - 'A' + rot) % 26);
  }
  // Anything else (numbers, symbols, control chars, etc) are unaltered
  return c;
}
</div></pre>


<p>
The first thing to notice is that Rot13Stream is derived from scx::Stream, the
base class for all stream classes. From this it inherits an interface for
reading and writing data, amongst other things.
</p>

<p>
The key point is that any reading and writing done by subsequent streams
associated with this socket will be done via our Rot13Stream, allowing us to
modify the data before it is read or written. This is done simply by 
overriding the <code>read()</code> and <code>write()</code> methods as shown.
</p>

<h3>Building the module</h3>

<p>
As with the previous example, building should be fairly straightforward 
provided SconeServer has been installed. However, as we now have multiple
source files, we need to compile each one seperately and link the objects.
This is best handles by a makefile, for example:
</p>

<pre class='file'><div class='head'>--- ../examples/rot13/Makefile.example ---</div><div class='body'>CFLAGS = -Wall
LIBS =  -lsconex
OBJS = Rot13Module.o Rot13Stream.o

all: rot13

rot13: $(OBJS)
	g++ -shared -o $@ $(OBJS) $(LIBS)

%o: %.cpp:
	g++ $(CFLAGS) -c $&lt;

clean:
	rm *.o core
</div></pre>


<p>
Building the module is then just a matter of typing:
</p>

<pre class='shell'>
<b>$</b> make
</pre>

<h3>Loading into SconeServer</h3>

<p>
Provided the module binary is located in SconeServer's module search path, it
can be loaded with the SconeScript command:
</p>

<pre class='script'>
insmod("rot13")
</pre>

<p>
As before, add this to "sconeserver.conf" if you want the module to be loaded 
every time SconeServer starts.
</p>

<h3>Using the module</h3>

<p>
The module will act as a filter to any module(s) following it in its route 
chain. To test it, we can create a chain and add our module followed by the
<a href="./modules/simple.html">simple</a> module's echo service (which echoes
back whatever it receives):
</p>

<pre class='script'>
router.add("rot13echo");
 router.rot13echo.add("rot13",0,1);
 router.rot13echo.add("simple","echo");
 router.rot13echo.listen(ip.addr("localhost",9000));
</pre>

<p>
The additional values (0 and 1) following "rot13" are arguments. These are 
passed to the module's <code>connect()</code> method when the chain is 
connected. For this module we use two arguments - flags to indicate whether 
the transform should be performed on the input and output respectively.
In this case we have selected just the output to be transformed.
</p>

<p>
We also set the chain to listen for connections on TCP port 9000. We can
then connect to the server using telnet and try it out:
</p>

<pre class='shell'>
<b>$</b> telnet localhost 9000
<b>Trying 127.0.0.1...</b>
<b>Connected to localhost.</b>
<b>Escape character is '^]'.</b>
abcdefg
<b>nopqrst</b>
gnat
<b>tang</b>
irk
<b>vex</b>
^]
<b>telnet&gt;</b> q
<b>Connection closed.</b>
</pre>

<p>
So there we have it - the characters we send are being transformed using 
rot13 and sent back!
</p>
</div>

<address>
Copyright (c) 2000-2005 Andrew Wedgbury / wedge (at) sconemad (dot) com
</address>
</body>
</html>
